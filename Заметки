Модуль 1, Глава 3
Мы можем наследовать от встроенных типов! Дополняя их поведение
Пример:

class ContactList(list):
    def search(self, name):
        matching_contacts = []
        return [contact for contact in self if name in contact.name]

class Contact:
    all_contacts = ContactList() - это переменная класса!
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.all_contacts.append(self)

В экземплярах класса Contact мы можем использовать такой код:
self.all_contacts - это будет равнозначно коду Contact.all_contacts. Но если мы присвоим self.all_contacts какое-то
значение в экземпляре класса, СОЗДАСТСЯ НОВАЯ ПЕРЕМЕННАЯ all_contacts ЭКЗЕМПЛЯРА КЛАССА! Сама классовая переменная
all_contacts НЕ ИЗМЕНИТСЯ! ВНИМАТЕЛЬНО!!!!

Функция super() - возвращает объект родительского класса, у которого мы можем, например, вызвать __init__
super().__init__(name, email)

Множественное наследование - очень аккуратно, можно нарваться на трудноотлавливаемые ошибки!
Пример:
class BaseClass:
    num_base_calls = 0
    def call_me(self):
        print("Calling method on Base Class")
        self.num_base_calls += 1
class LeftSubclass(BaseClass):
    num_left_calls = 0
    def call_me(self):
        super().call_me()
        print("Calling method on Left Subclass")
        self.num_left_calls += 1
class RightSubclass(BaseClass):
    num_right_calls = 0
    def call_me(self):
        super().call_me()
        print("Calling method on Right Subclass")
        self.num_right_calls += 1
class Subclass(RightSubclass, LeftSubclass):
    num_sub_calls = 0
    def call_me(self):
        super().call_me()
        print("Calling method on Subclass")
        self.num_sub_calls += 1

В данном случае, метод call_me вызванный у Subclass срабатывает так: вызывается super().call_me(), а какой класс здесь
super? Это определяется порядком наследования!!! Т.е. super для Subclass - RightSubclass! Его метод call_me и super
ведет ко второму классу в порядке наследования, к LeftSubclass! И только его super приведет к BaseClass!!!!!
Т.е. при множественном наследовании super ведет себя как NEXT. Да и не только при множественном скорее всего.
В общем - аккуратно с переопределяемыми методами при множественном наследовании, и надо учитывать порядок списка
наследуемых классов!
